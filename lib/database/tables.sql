
---------------------------------------

-------Production Table ---------------
create table
  public.production (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    farm_id bigint not null,
    amber_id bigint not null,
    "prodDate" date not null,
    incom_feed integer null,
    intak_feed numeric null,
    "prodTray" bigint null,
    "prodCarton" bigint null,
    "outTray" bigint null,
    "outCarton" bigint null,
    "outEggsNote" character varying null,
    death bigint null,
    remain_egg_tray numeric null,
    remain_carton_tray numeric null,
    remain_feed numeric null,
    constraint production_pkey primary key (farm_id, amber_id, "prodDate"),
    constraint production_farm_id_fkey foreign key (farm_id) references farms (id) on update restrict on delete restrict,
    
  ) tablespace pg_default;

------Trigger on insert into production table-----
create trigger on_add_production
after insert
 on production for each row
execute function calculate_inventory_quantity ();




---------------------Ambers Table-----------------------
--ambers table
create table
  public.ambers (
    id bigint generated by default as identity,
    quantity bigint null,
    age bigint null,
    other_details character varying null,
    farm_id bigint not null,
    amber_id bigint not null,
    constraint ambers_pkey primary key (id, farm_id, amber_id),
    --constraint ambers_id_key unique (id),
    constraint farm_amber_id_key unique (farm_id, amber_id)
  ) tablespace pg_default;


---------------------Farm Table-----------------
  --farm table
  create table
  public.farms (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    farm_name text not null,
    farm_type public.type_of_poultry not null,
    no_of_ambers bigint not null,
    farm_start_date date null,
    farm_end_date date null,
    "isRunning" boolean not null default true,
    farm_supervisor uuid null,
    constraint farms_pkey primary key (id),
    constraint farms_farm_name_key unique (farm_name),
    constraint farms_farm_supervisor_fkey foreign key (farm_supervisor) references supervisors (u_id)
  ) tablespace pg_default;

---------Trigger to create Ambers after insert into farm table---------------
create trigger insert_ambers
after insert
or
update on farms for each row
execute function create_ambers ();

--function triggered when create new farm to create ambers
--create_ambers
BEGIN
  FOR i IN 1..NEW.no_of_ambers LOOP
  INSERT INTO ambers(farm_id,amber_id)
values(NEW.id,i);

END LOOP;
RETURN NEW;
END;

---------Trigger to create companation of farmId and AmberId in inventory table after insert into farm table---------------
create trigger insert_inventory
after insert
or
update on farms for each row
execute function create_inventory ();

------------------Function to get all items to insert into inventory
CREATE OR REPLACE FUNCTION get_all_item_code() RETURNS SETOF varchar AS
$BODY$
DECLARE
    r varchar;
BEGIN
    FOR r IN
        SELECT item_code FROM items
    LOOP
        RETURN NEXT r; -- return current row of SELECT
    END LOOP;
    RETURN;
END;
$BODY$
LANGUAGE plpgsql;
---------------------------------------
create or replace function create_inventory () returns void language plpgsql as $$
DECLARE
    r varchar;
    myarr varchar[]:=array(select * from get_all_item_code());
BEGIN
 raise info '%', myarr;
  FOR i IN 1..3 LOOP
    ForEach r IN  array myarr LOOP
         INSERT INTO inventory(farmid,ambid,item_code)
      values(1,i,r);
    END Loop;

 END LOOP;
RETURN void;
END;
$$;



--create inventory function
DECLARE
    r varchar;
    myarr varchar[]:=array(select * from get_all_item_code());
BEGIN

  FOR i IN 1..NEW.no_of_ambers LOOP
    ForEach r IN array myarr LOOP
         INSERT INTO inventory(farm_id,amber_id,item_code,quantity,small_quantity)
      values(NEW.id,i,r,0,0);
    END LOOP;

 END LOOP;
RETURN NEW;
END;


--inventory table
create table
  public.inventory (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    farm_id bigint not null,
    amber_id bigint not null,
    item_code character varying not null,
    quantity numeric null default '0'::numeric,
    small_quantity integer null default 0,
    constraint inventory_pkey primary key (id, farm_id, amber_id),
    constraint inventory_farm_id_fkey foreign key (farm_id) references farms (id) on update cascade on delete cascade,
    constraint inventory_small_quantity_check check ((small_quantity < 12))
    constraint inventory_small_quantity_check2 check (small_quantity >= 1)
  ) tablespace pg_default;
  ////////////////////////////////////////////

--function that triggered on insert to production table to update the inventory table
--calculate_inventory_quantity

create function update_inventory_quantity() returns as trigger
as $body$
language plgsql;
declare
in_feed numeric :=New.incom_feed;
out_feed numeric:=New.intak_feed;
prod_carton int :=New."prodCarton";
prod_tray int :=New."prodTray";
out_carton int :=New."outCarton";
out_tray int :=New."outTray";
no_death int :=New.death;

feed_amount numeric :=quantity from inventory where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code='001-002';
egg_carton_amount int :=quantity from inventory where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code='001-003';
egg_try_amount int :=small_quantity from inventory where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code='001-003';
no_of_hens int := quantity from inventory where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code='001-001';

nums int[]=ARRAY[]::int[]; --:=select calculate_eggs(prod_tray,prod_carton);
begin
no_of_hens :=no_of_hens-no_death;
feed_amount :=feed_amount + in_feed - out_feed;
egg_carton_amount :=egg_carton_amount+prod_carton-out_carton;
egg_try_amount := egg_try_amount+prod_tray-out_tray;
nums :=array(select calculate_egg(egg_try_amount,egg_carton_amount));
egg_carton_amount := elem from 
   unnest (nums)
             with ordinality as a(elem,idx)
         where idx = 2;
egg_try_amount :=elem from 
   unnest (nums)
             with ordinality as a(elem,idx)
         where idx = 1;

update inventory set quantity = no_of_hens where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code='001-001';
update inventory set quantity = feed_amount where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code='001-002'; 
update inventory set quantity = egg_carton_amount,small_quantity=egg_try_amount where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code='001-003';

return new;
end;    
----------------------------function that trigger on update production to recalculate the inventory quantities---------
---------------------- called by on_producrion_update trigger --------------------------------------
create or replace function update_inventory_quantity_after_update_production() returns  trigger language plpgsql
as $body$

declare
in_feed numeric :=New.incom_feed;
out_feed numeric:=New.intak_feed;
prod_carton int :=New."prodCarton";
prod_tray int :=New."prodTray";
out_carton int :=New."outCarton";
out_tray int :=New."outTray";
no_death int :=New.death;

feed_amount numeric :=quantity from inventory where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code='001-002';
egg_carton_amount int :=quantity from inventory where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code='001-003';
egg_try_amount int :=small_quantity from inventory where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code='001-003';
no_of_hens int := quantity from inventory where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code='001-001';

nums int[]=ARRAY[]::int[]; --:=select calculate_eggs(prod_tray,prod_carton);
--the old row of current update
old_row production%rowtype :=Old;
begin
 --if (TG_OP = 'UPDATE') then
 no_of_hens :=no_of_hens+old_row.death-no_death;
feed_amount :=feed_amount -(old_row.incom_feed-old_row.intak_feed)+(in_feed - out_feed);
egg_carton_amount :=egg_carton_amount-(old_row."prodCarton"-old_row."outCarton")+(prod_carton-out_carton);
egg_try_amount := egg_try_amount-(old_row."prodTray"-old_row."outTray")+(prod_tray-out_tray);
nums :=array(select calculate_egg(egg_try_amount,egg_carton_amount));
egg_carton_amount := elem from 
   unnest (nums)
             with ordinality as a(elem,idx)
         where idx = 2;
egg_try_amount :=elem from 
   unnest (nums)
             with ordinality as a(elem,idx)
         where idx = 1;
-- else
-- no_of_hens :=no_of_hens-no_death;
-- feed_amount :=feed_amount + in_feed - out_feed;
-- egg_carton_amount :=egg_carton_amount+prod_carton-out_carton;
-- egg_try_amount := egg_try_amount+prod_tray-out_tray;
-- nums :=array(select calculate_egg(egg_try_amount,egg_carton_amount));
-- egg_carton_amount := elem from 
--    unnest (nums)
--              with ordinality as a(elem,idx)
--          where idx = 2;
-- egg_try_amount :=elem from 
--    unnest (nums)
--              with ordinality as a(elem,idx)
--          where idx = 1;
-- end if;
update inventory set quantity = no_of_hens ,updated_at = current_timestamp  where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code='001-001';
update inventory set quantity = feed_amount,updated_at = current_timestamp  where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code='001-002'; 
update inventory set quantity = egg_carton_amount,small_quantity=egg_try_amount,updated_at = current_timestamp  where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code='001-003';


return new;
end;    
$body$

;
create or replace trigger on_update_production
before update on production for each row
execute function update_inventory_quantity_after_update_production ();




/////////////////////////////////////
  --claculate egg tray and cartoons
  -------أهم دالة والتي تحسب الكراتين والاطباق البيض  
  ///calculate tray and carton
create or replace function calculate_egg(tray int, carton int)
  returns SETOF int[]
language plpgsql as $Body$
--language plpgsql as $Body$
DECLARE
   remainTray int; 
   remainCar int ;
    var int;
 nums int[] :=ARRAY[]::int[];
  
BEGIN
 -- raise info '%', tray;
   if tray>0
     then
        if tray >11 then
          remainTray := (select MOD(tray,12));
          remainCar := (tray/12)+carton;
        else 
           remainTray :=tray;
           remainCar :=carton;
        end if;
  else 
     if tray = 0 then
       remainTray :=0;
       remainCar :=carton;
    else
      if tray<=-12 then
        remainCar :=tray%12;
         var :=tray/12;
         remainTray :=(12+remainCar);
        remainCar :=carton+var-1;
     else 
         remainCar :=carton -1;
         remainTray :=tray+12;
      end if;
      end if;
  end if;
  select array[remainTray::int,remainCar::int] into nums;
RETURN nums;
END ;
------------------------------------Item_Movements_Table----------------------
  --items movement table
  create table
  public.item_movement (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    farm_id bigint null,
    amber_id bigint null,
    item_code character varying null,
    type_movement character varying null default '{''وارد'',''خارج''}'::character varying,
    movement_date date null,
    quantity numeric null,
    notes character varying null,
    constraint item_movement_pkey primary key (id),
    constraint item_movement_farm_id_fkey foreign key (farm_id,amber_id) references ambers(farm_id,amber_id),
    constraint item_movement_item_code_fkey foreign key (item_code) references items (item_code)
  ) tablespace pg_default;
  --table of items
  create table
  public.items (
    id bigint generated by default as identity,
    item_code character varying not null,
    item_name character varying not null,
    constraint items_pkey primary key (id, item_code),
    constraint items_item_id_key unique (item_code)
  ) tablespace pg_default;
------------------------------------------calculate inventory quantities based on insert into item_movement---
create or replace function update_inventory_based_items_movement() returns trigger language plpgsql
as $body$
declare
in_farm_id int :=New.farm_id;
in_amber_id int :=New.amber_id;
--item_code varchar :=New.item_code;
in_quantity numeric:=New.quantity;
--type_move varchar :=New.type_movement;
itemCode varchar :=item_code from inventory where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code=New.item_code;--check if the item in inventory
last_amount numeric :=quantity from inventory where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code=New.item_code; --get the previous amount from inventory
sub_quantity  int:=small_quantity from inventory where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code='001-003';
--used to get the amount of cartoons only if the item_code=001-004
egg_carton_amount int;
egg_try_amount int;

--used to calculate tray and carton if item_code=001-004
nums int[]=ARRAY[]::int[]; --:=select calculate_eggs(prod_tray,prod_carton);
begin

if New.type_movement ='خارج'
 then

--- if the itemcode is طبق so we need to calculata the remaining cartons and tray
if New.item_code ='001-004'
   then
   egg_carton_amount :=quantity from inventory where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code='001-003';
   --RAISE NOTICE 'Value: (%)', egg_carton_amount;
   sub_quantity :=sub_quantity-in_quantity;
   --RAISE NOTICE 'Value: (%)', sub_quantity;
   nums :=array(select calculate_egg(sub_quantity,egg_carton_amount));
  egg_carton_amount := elem from 
   unnest (nums)
             with ordinality as a(elem,idx)
         where idx = 2;
   egg_try_amount :=elem from 
   unnest (nums)
             with ordinality as a(elem,idx)
         where idx = 1;
      update inventory set quantity = egg_carton_amount,small_quantity=egg_try_amount where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code='001-003';

 else
      --- if the itemCode so this is the first time insert the item into the inventory
       if itemCode is NULL
            then
           insert into inventory(farm_id,amber_id,item_code,quantity)
            values(New.farm_id,New.amber_id,New.item_code,New.quantity);
         else
        last_amount :=last_amount-in_quantity;
        update inventory set quantity=last_amount  where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code=New.item_code;
      end if;
   end if;
--------- so the type movement is وارد ---
  else 
   --- if the itemCode so this is the first time insert the item into the inventory
     if itemCode is NULL then
      insert into inventory(farm_id,amber_id,item_code,quantity) values(New.farm_id,New.amber_id,New.item_code,New.quantity);
      else
      last_amount :=last_amount+in_quantity;
     update inventory set quantity=last_amount  where (farm_id=New.farm_id and amber_id =New.amber_id) and item_code=New.item_code;
     end if;
 end if;
 return new;
 end;
$body$





------------------------------------
  --table of supervisor
  create table
  public.items (
    id bigint generated by default as identity,
    item_code character varying not null,
    item_name character varying not null,
    description character varying null,
    constraint items_pkey primary key (id, item_code),
    constraint items_item_id_key unique (item_code)
  ) tablespace pg_default;
